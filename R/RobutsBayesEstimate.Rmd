---
title: "RobutsBayesEstimate"
author: "Kaan Keskin"
date: "2024-04-09"
output: pdf_document
---
 Robust Bayesian estimation between groups  https://m-clark.github.io/models-by-example/bayesian-t-test.html 
 explains the process 

```{r setup, include=FALSE}
library(rstan)
library(R.matlab)
library(reshape2)
```

```{r}
library(tidyverse)

set.seed(1234)

N_g   = 2       # N groups
N_1   = 33      # N for group 1
N_2   = 327      # N for group 2
mu_1  = 1       # mean for group 1
mu_2  = -.5     # mean for group 1
sigma_1 = 1     # sd for group 1
sigma_2 = 1     # sd for group 1

y_1 = rnorm(N_1, mu_1, sigma_1)
y_2 = rnorm(N_2, mu_2, sigma_2)
y   = c(y_1, y_2)

# group_id = as.numeric(gl(2, N_1))

# if unbalanced
group = 1:2
group_id = rep(group, c(N_1,N_2))

d = data.frame(y, group_id)

```

```{r}
dat <- readMat( "C:/Users/kaan/Documents/NatComm2023/MYELIN/DATA/INT_all.mat" )
dat2 <- readMat( "C:/Users/kaan/Documents/NatComm2023/MYELIN/DATA/MED.mat" )
GSCORR <- readMat( "C:/Users/kaan/Documents/NatComm2023/MYELIN/DATA/GSCORR.mat" )$GSCORR.arr
  
ACW0 <- t( dat$ACW0.all )
dat_ACW0 <- data.frame(ACW0)
dat_ACW0$class <- dat2$MED[,5]

long_ACW0 <- melt(dat_ACW0, variable.name = "Variable", value.name = "Value")
long_ACW0$class <- rep(dat2$MED[,5],each=100)

data_frame <- as.data.frame(GSCORR)
data_frame$class <- dat2$MED[,5]

# Melt the data frame to long format
long_data <- melt(data_frame, id.vars = "class")

```

```{r}
stan_data = list(
  N   = length(y),
  N_g = N_g,
  group_id = group_id,
  y = y
)

stan_data = list(
  N   = length(dat2$MED[,5]),
  N_g = 2,
  group_id = dat2$MED[,5],
  y = dat2$MED[,1]
)

stan_data = list(
  N   = length(long_data$value),
  N_g = 2,
  group_id = long_data$class,
  y = long_data$value
)


library(rstan) 

null_model <-  stan_model("C:/Users/kaan/Documents/NatComm2023/MYELIN/R/null_model.stan")
bayes_t_test <- stan_model("C:/Users/kaan/Documents/NatComm2023/MYELIN/R/bayes_t_test.stan")


fit_null = sampling(
  null_model,
  data = stan_data,
  thin = 4, 
  cores = 4
)

fit_alt = sampling(
  bayes_t_test,
  data = stan_data,
  thin = 4, 
  cores = 4
)

library(bridgesampling)

bridge_null = bridge_sampler(fit_null)
bridge_alternative = bridge_sampler(fit_alt)

bf_result = bf(bridge_alternative, bridge_null)
print(bf_result)

```

```{r}
# Posterior Predictive check by hand 
library(rethinking)
prior_alt <- extract.samples( fit_alt, n=1000 )

# Parameters for demonstration. Replace with your actual data and parameters.
N_sim <- 1000 # total number of observations
N_g <- 2 # number of groups
group_id <- sample(1:N_g, N, replace = TRUE) # Randomly assign observations to 2 groups for demonstration

nu <- prior_alt$nu # degrees of freedom for the t-distribution, shared across groups in this example
mu <- prior_alt$mu # mean for each group
sigma <- prior_alt$sigma # standard deviation for each group

y_simulated <- matrix(nrow = N_sim, ncol = N_sim+1) # First column is for group

for (i in 1:N_sim) {
      group_id_n <- sample(1:N_g, 1) # Randomly assign each data point to a group
      # and saving to the first column
  for (n in 1:N_sim) {
    y_simulated[i,1] <- group_id_n # Saving the which group belonged to
    nu_i <- nu[i]
    mu_i <- mu[i, group_id_n]
    sigma_i <- sigma[i, group_id_n]
# THIS PART IS NOT TRUE, Look the MediationGLMM in MYELIN for the ture part. should be rt(1e3, ...)
# ALSO easier with with and sapply 
    y_simulated[i, n+1] <- rt(1, df = nu_i) * sigma_i + mu_i # Generate the data point
  }
}

# You can now work with y_simulated as your estimated y values based on the model parameters and group assignments

```

```{r}
# Plotting the posteriors 
# Assuming y_simulated is already created and filled with your data
set.seed(123) # For reproducibility

# Choose a few rows randomly or sequentially. Here, we'll do it sequentially for simplicity
rows_to_plot <- seq(2, 1000, by = 20) # For example, plotting every 200th row
colors <- rainbow(N_g) # Generate distinct colors
alpha = 0.2

# Initialize the plot with the first density
dens <- density(y_simulated[rows_to_plot[1], ])
plot(dens, main = "Density of Simulated Data", xlab = "Simulated Values", ylab = "Density", type = 'l', col = 1)

# Add the rest of the densities using lines()
for (i in 2:length(rows_to_plot)) {
  dens <- density(y_simulated[rows_to_plot[i], ])
  lines(dens, col = col.alpha(colors[y_simulated[i,1]],0.4)) # Use different colors for clarity
}

# Add a legend if needed
legend("topright", legend = paste("Row", rows_to_plot), col = 1:length(rows_to_plot), lty = 1)

```

```{r}
# Posterior predictive check with function
library(bayesplot)

pp_check(
  stan_data$y,
  rstan::extract(fit_alt, par = 'y_rep')$y_rep[,1:360 ],
  fun = 'dens_overlay'
)


```